# -*- coding: utf-8 -*-
"""Copy of Final_BLM.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1zY0pO2ilWg-qUKJi-slSpGOgFsisWBUX

## **Import Libraries**
"""

#data-manipulation
import pandas as pd
import numpy as np
import nltk

#dtata-visualization
import matplotlib.pyplot as plt
import seaborn as sns

#financial-data & black litterman model
!pip install yfinance
!pip install PyPortfolioOpt
import yfinance as yf
from pypfopt import black_litterman, risk_models
from pypfopt.black_litterman import BlackLittermanModel
from pypfopt.efficient_frontier import EfficientFrontier

"""# **Test Space**"""

#identify risk-free rate to find implied returns using ^IRX (13 Week T-Bill)
price_df = yf.download(
    ['^IRX','AAPL','BBY','BAC','SBUX','T'],
    start='2017-01-01',
    end='2020-01-01',
    interval='1mo').dropna().pct_change()[1:]

"""# **Black Letterman Inputs**"""

#identify risk-free rate to find implied returns using ^IRX (13 Week T-Bill)
def risk_free(start_date, end_date):
    rfdf = yf.download('^IRX',start=start_date,end=end_date,interval='1d').dropna()
    return rfdf['Adj Close']

def market_data(start_date,end_date):
        market_df = yf.download('^GSPC',start=start_date,end=end_date,interval='1d').dropna()
        return market_df['Adj Close']

def get_historicals(start_date,stock_tickers,end_date,data_type='Adj Close',returns=True):
    """
        Pulls the historical data from a specified start_date and end_date.
        start_date: '20xx-MM-DD'
        data_type: lets you choose between Open, Close, AdjClose
        returns: returuns the pct_change data frame
        stock_tickers: list of stock_tickers interest
    """
    if returns:
        historicals = yf.download(
            ['^IRX']+stock_tickers,
            start=start_date,
            end=end_date,
            interval='1d'
        ).dropna()
    else:
        historicals = yf.download(
            ['^IRX']+stock_tickers,
            start=start_date,
            end=end_date,
            interval='1d'
        ).dropna().pct_change().dropna()[1:]

    return historicals[data_type]

def risk_premium(returns_df,cov = True):
    temp = pd.DataFrame()
    for i in returns_df.columns:
        temp[i] = returns_df['^IRX']
    premium = returns_df - temp
    if cov:
        return premium.cov().iloc[0:-1,:-1]
    else:
        return premium.iloc[0:-1,:-1]

def market_cap(stock_tickers):
    market_cap = {}
    for t in stock_tickers:
        stock = yf.Ticker(t)
        market_cap[t] = stock.info["marketCap"]
    return market_cap

# Oct 17 add cell generate P Q matrix
# import numpy as np
class pqmatrix:
    def __init__(self,port_li,view_dict):
        '''
        port list should contain all tickers we manage
        it keeps the view function not to make an error
        ex):["AAPL","BBY","SBUX","T","BAC"]
        '''
        self.tickers=port_li
        self.view_dict=view_dict
        self.p=list()
        self.q=list()
    def __len__(self):
        return len(self.tickers)
    def q_func(self):
        tmp_idx=list()
        #index matching
        for key in self.view_dict.keys():
            tmp_idx.append(self.tickers.index(key))
        for ele in tmp_idx:
            x=self.tickers[ele]
            self.q.append(self.view_dict[x])
        return np.array(self.q)
    def p_func(self,view):
        '''
        view = {inc:['ABC','DEF'],dec:['GHI']}
        '''
        inc_idx=list()
        dec_idx=list()
        tmp_p=list(0 for i in range(len(self.tickers)))
        #inc
        inc_li=view['inc']
        if len(inc_li)!=0:
            for ele in inc_li:
                inc_idx.append(self.tickers.index(ele))
            for idx in inc_idx:
                if len(inc_idx)>1:
                    tmp_p[idx]=0.5
                else:
                    tmp_p[idx]=1
        #dec
        dec_li=view['dec']
        if len(dec_li)!=0:

            for ele in dec_li:
                dec_idx.append(self.tickers.index(ele))
            for idx in dec_idx:
                if len(dec_idx)>1:
                    tmp_p[idx]=-0.5
                else:
                    tmp_p[idx]=1
        self.p.append(tmp_p)

    def __call__(self):
        p=self.p
        p=np.array(p).reshape(len(p),-1)
        q=self.q_func()
        q=q.reshape(-1,1)
        print('this is p')
        print(p)
        print('this is q')
        print(q)

        print(np.dot(p,q))
        return np.dot(p,q)
tickerlist=['AAPL','BBY','BAC','SBUX','T']
viewdict = {"AAPL": 0.20, "BBY": -0.30, "BAC": 0, "SBUX": -0.2, "T": 0.15}
view_inc_dec ={'inc':["AAPL","BBY"],'dec':['BAC','SBUX']}
view_inc_dec2 ={'inc':["T"],'dec':['BAC',]}
view_inc_dec3 ={'inc':[],'dec':['BBY',]}
pqmat=pqmatrix(tickerlist,viewdict)
pqmat.p_func(view_inc_dec)
pqmat.p_func(view_inc_dec2)
pqmat.p_func(view_inc_dec3)
pqmat()

def QandPMatrix(views,stock_ticker):
    #Assume it's in format: [[('MSFT','>','GE'),0.02],['MSFT',0.02]]
    q_matrix = []
    p_matrix = np.zeros((len(views),len(stock_ticker)))
    for view in views:
        q_matrix.append(view[1])
    for i in range(len(views)):
        if type(views[i][0]) is str:
            pos = stock_ticker.index(views[i][0])
            p_matrix[i][pos] = 1
        else:
            pos_1 = stock_ticker.index(views[i][0][0])
            pos_2 = stock_ticker.index(views[i][0][2])
            if views[i][0][1] == '>':
                p_matrix[i][pos_1] = 1
                p_matrix[i][pos_2] = -1
            else:
                p_matrix[i][pos_1] = -1
                p_matrix[i][pos_2] = 1
    return [q_matrix,p_matrix]

def RunBlackLittermanModel(start_date, end_date,stock_tickers,views):
    delta = black_litterman.market_implied_risk_aversion(
        market_data(start_date,end_date),
        frequency=252,
        risk_free_rate= risk_free(start_date, end_date)
    ).mean()
    returns_df = get_historicals(start_date,stock_tickers,end_date)
    cov_matrix = risk_premium(returns_df,cov = True)
    prior = black_litterman.market_implied_prior_returns(
        market_cap(stock_tickers),
        delta,
        cov_matrix
      )
    tau = 0.05
    QandP = QandPMatrix(views,stock_tickers)
    print(QandP)
    Q = np.transpose(QandP[0])
    P = QandP[1]
    omega = tau * np.dot(np.dot(P,risk_premium(returns_df,cov = True)),np.transpose(P))
    bl = BlackLittermanModel(
        cov_matrix = cov_matrix,
        pi = prior,
        Q = Q,
        P = P,
        omega = omega,
        tau = tau
    )
    bl.bl_weights(delta)
    bl_weights = dict(bl.clean_weights())
    bl_rets = bl.bl_returns()
    return (bl_weights,bl_rets)

"""# RunBlackLittermanModel"""

RunBlackLittermanModel(
    '2020-01-01',
    '2021-01-01',
    ['AAPL','AMZN','CCL','NCLH'],
    [[('AAPL','>','CCL'),1],['AMZN',0.30],[('AMZN','>','NCLH'),1]]
)

